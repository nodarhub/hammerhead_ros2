cmake_minimum_required(VERSION 3.10)

project(hammerhead_msgs LANGUAGES C CXX)

if (POLICY CMP0148)
    cmake_policy(SET CMP0148 OLD)
endif ()
find_package(Python3 REQUIRED COMPONENTS Interpreter Development)

include(GNUInstallDirs)

find_package(rosidl_default_generators REQUIRED)
find_package(sensor_msgs REQUIRED)
find_package(std_msgs REQUIRED)

add_library(hammerhead_msg_lib INTERFACE)

rosidl_generate_interfaces(
        hammerhead_msgs
        msg/Obstacle.msg
        msg/ObstacleData.msg
        msg/PointCloudSoup.msg
        srv/CameraParam.srv
        DEPENDENCIES
        sensor_msgs
        std_msgs
        SKIP_INSTALL # This tells ros2 not to install anything. We will do it.
)

add_dependencies(hammerhead_msg_lib hammerhead_msgs)
if (TARGET hammerhead_msgs__rosidl_typesupport_cpp)
    get_target_property(_incs hammerhead_msgs__rosidl_typesupport_cpp INTERFACE_INCLUDE_DIRECTORIES)
    if (_incs AND NOT _incs STREQUAL "include_directories-NOTFOUND")
        target_include_directories(hammerhead_msg_lib INTERFACE ${_incs})
    endif ()
    target_link_libraries(hammerhead_msg_lib INTERFACE hammerhead_msgs__rosidl_typesupport_cpp)
    message("Wiring up hammerhead_msg_lib")
else ()
    message(WARNING "hammerhead_msgs__rosidl_typesupport_cpp doesn't exist")
endif ()

# Manually install the generated targets into our libdir.
# We defensively check which ones exist
set(ROSIDL_TARGETS
        hammerhead_msgs__rosidl_generator_c
        hammerhead_msgs__rosidl_generator_cpp
        hammerhead_msgs__rosidl_generator_py
        hammerhead_msgs__rosidl_typesupport_c
        hammerhead_msgs__rosidl_typesupport_cpp
        hammerhead_msgs__rosidl_typesupport_fastrtps_c
        hammerhead_msgs__rosidl_typesupport_fastrtps_cpp
        hammerhead_msgs__rosidl_typesupport_introspection_c
        hammerhead_msgs__rosidl_typesupport_introspection_cpp
)
set(PRESENT_TARGETS)
foreach (t ${ROSIDL_TARGETS})
    if (TARGET ${t})
        list(APPEND PRESENT_TARGETS ${t})
    endif ()
endforeach ()

if (PRESENT_TARGETS)
    # Yes we need the install in both locations...
    install(TARGETS ${PRESENT_TARGETS}
            ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
            LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
            RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
    )
    install(TARGETS ${PRESENT_TARGETS}
            EXPORT export_${PROJECT_NAME}  # generate proper *Export.cmake with your paths
            ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}/${CMAKE_PROJECT_NAME}
            LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}/${CMAKE_PROJECT_NAME}
            RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}/${CMAKE_PROJECT_NAME}
    )
endif ()

# Headers generated by rosidl still need to be installed.
#    If your distro of rosidl skips installing headers under SKIP_INSTALL,
#    uncomment these lines to install them manually.
install(DIRECTORY
        ${CMAKE_CURRENT_BINARY_DIR}/rosidl_generator_c/${PROJECT_NAME}
        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/${PROJECT_NAME}
)
install(DIRECTORY
        ${CMAKE_CURRENT_BINARY_DIR}/rosidl_generator_cpp/${PROJECT_NAME}
        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/${PROJECT_NAME}
)

# Install the interface lib
# Yes we need the install in both locations...
install(TARGETS hammerhead_msg_lib
        DESTINATION ${CMAKE_INSTALL_LIBDIR}
)
install(TARGETS hammerhead_msg_lib
        EXPORT export_${PROJECT_NAME}
        DESTINATION ${CMAKE_INSTALL_LIBDIR}/${CMAKE_PROJECT_NAME}
)

# Install the export set
install(
        EXPORT export_${PROJECT_NAME}
        DESTINATION share/${PROJECT_NAME}/cmake
        NAMESPACE ${PROJECT_NAME}::
)

ament_export_targets(export_${PROJECT_NAME} HAS_LIBRARY_TARGET)

# Install the generated Python message package into the versioned libdir
set(_python_out "${CMAKE_CURRENT_BINARY_DIR}/rosidl_generator_py/${PROJECT_NAME}")
if (EXISTS "${_python_out}")
    install(
            DIRECTORY "${_python_out}/"
            DESTINATION "${CMAKE_INSTALL_LIBDIR}/python${Python3_VERSION_MAJOR}.${Python3_VERSION_MINOR}/site-packages/${PROJECT_NAME}")
endif ()
ament_package()
